#! /usr/bin/env python

# Python imports
import logging
import inspect
import os
import Queue
import sys
import threading
import traceback

# Voltage imports
import voltage
from voltage.testrunner import publisher
from voltage import signalhelper
from voltage import utils

# Global variables
RUN_UNTIL_SUCCESS = None
SETUP = 'setup'
SUCCEEDED = None
TEARDOWN = 'teardown'
TESTS_QUEUE = None

def init_test_queue():
    global SUCCEEDED, TESTS_QUEUE
    TESTS_QUEUE = Queue.Queue()
    SUCCEEDED = {}

class Worker(threading.Thread):
    """
    Thread class that pulls tests off the queue of tests to be executed,
    does the test case execution, and puts the results on the result queue.
    """
    def __init__(self, finished_callback, *args, **kwargs):
        super(Worker, self).__init__(*args, **kwargs)
        self._finished_callback = finished_callback

    def run(self):
        test_obj = None

        while True:
            testcase = TESTS_QUEUE.get()
            print "howdy"
            print TESTS_QUEUE.qsize()
            try:
                if os.getenv('KEEP_RUNNING') == 'True':

                    # Use the voltage-logger created in runner.py
                    logger = utils.get_logger()
                    
                    if not RUN_UNTIL_SUCCESS or not testcase.signature in SUCCEEDED:

                        try:
                            logger.info('Executing: %s'% testcase.signature)
                        except Exception, ex:
                            logger.exception(ex)

                        if testcase.is_unittest:
                            # Instantiate the unittest class, and fetch the callable
                            unittest = getattr(testcase.module, testcase.cls)()
                            unittest.signature = testcase.signature
                            fcn = getattr(unittest, testcase.fcn)

                            # Setup method
                            setup = getattr(unittest, SETUP, None)

                            if inspect.ismethod(setup):
                                setup()

                            # Call the unittest class method
                            test_obj = fcn()

                            # Teardown method
                            teardown = getattr(unittest, TEARDOWN, None)

                            if inspect.ismethod(teardown):
                                teardown()

                        else:
                            fcn = getattr(testcase.module, testcase.fcn)
                            test_obj = fcn()

                    else:
                        msg = 'Skipping from previous PASS: %s' % testcase.signature
                        try:
                            logger.info(msg)
                        except Exception, ex:
                            logger.exception(ex)
                        test_obj = voltage.Test()
                        test_obj['status'] = voltage.test.UNNEEDED

                else:
                    test_obj = voltage.Test()
                    test_obj['status'] = voltage.test.SUSPENDED

            except Exception, ex:
                errmsg = 'Unhandled Exception encountered while executing test case. ' \
                      + 'Please include a try catch block in your test case'
                unhandled_exception = utils.get_exception_from_stack(errmsg)
                test_obj = voltage.Test()
                test_obj['test_exception'] = unhandled_exception
                test_obj['test_exception']['is_handled'] = False
                test_obj['status'] = voltage.test.ERROR

            finally:
                if test_obj['status'] == voltage.test.PASS:
                    SUCCEEDED[testcase.signature] = True
                #Note: We raise the signal and wake up the main thread
                #before pushing the result object on the queue
                #because of the potential race condition that could arise
                #during the execution of the last test
                is_finished = self._finished_callback()
                # Signal the main thread if this was the last task.
                if is_finished:
                    signalhelper.raise_and_validate_signal()
                publisher.RESULTS_QUEUE.put((testcase, test_obj))
                TESTS_QUEUE.task_done()

