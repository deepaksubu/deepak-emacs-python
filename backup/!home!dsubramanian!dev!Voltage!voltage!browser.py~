
"""
Subclass of the upstream selenium browser class.
"""

# Python imports
import os
import re
import sys
import time

# Voltage imports
import voltage
from voltage import mixins
from voltage import user_exceptions
from voltage import utils
from voltage.protocol import http_raw_client
from voltage.vendor.selenium import selenium as selenium_rc

# The selenium module expects itself to be in the PYTHONPATH
cmd_folder = os.path.join(os.path.dirname(__file__), 'vendor')
if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)
from selenium import webdriver

FILESERVER = "http://ninja.mygazoo.com:5554/"
RE_URL_PROTOCOL = re.compile(r'^(https|http|ftp)://')

class Browser(selenium_rc, mixins.FlowMixin):
    def __init__(self, test, config=None):
        self.test = test
        self._logger = utils.get_logger()
        # Reset the pages count
        self.pages_explored = set([]);

        if config is None:
            self.config = voltage.config_loader.get_config()
        else:
            self.config = config
        print "Deepak:Super Class"
        browser = self.config.browser
        target = self.config.target
        #verify if the target url is not malformed
        if not RE_URL_PROTOCOL.match(target):
            raise user_exceptions.MalformedURLError("Malformed URL Encountered: '%s'" % target)

        while True:
            remote = self.config.fetch_remote()
            self.host, self.port = remote.split(':')
            port = int(self.port)

            super(Browser, self).__init__(self.host, port, browser, target)

            # Try to startup a browser, and set initial speed
            try:
                self.start(config["selenium"]["capture_network_traffic"])
                self.set_speed(int(self.config.speed))
                self.set_timeout(int(self.config.max_wait))
                msg = 'Executing %s via %s'
                try:
                    self._logger.info(msg % (test.signature, remote))
                except Exception, ex:
                    self._logger.info('...Using browser via %s' % remote)

                break
            except Exception, ex:
                self._logger.error('Unable to hit:%s\n%s' % (remote, ex))
                self.config.dead_remote(remote)
                pass

    def execute(self, *args, **kwargs):
        print "Deepak: execute This is it"
        return super(Browser, self).execute(self, *args, **kwargs)

    def start(self, capture_network_traffic=False):
        """
        Overloaded start method to add (optional) support for
        capturing network traffic.
        """

        args = [self.browserStartCommand, self.browserURL, self.extensionJs]
        print "Deepak: start This is it"
        # To bypass SSL certs in Chrome we need to pass an extra flag
        if self.config.browser == '*googlechrome':
            args.append('commandLineFlags=--disable-web-security')

        if capture_network_traffic:
            args.append("captureNetworkTraffic=true")

        result = self.get_string("getNewBrowserSession", args)

        try:
            self.sessionId = result
        except ValueError:
            raise Exception, result

        self.register_url()

    def breakpoint(self, condition=False, timeout=300):
        """
        When called this will wait for the specified timeout.  This is
        useful for stopping the browser at a particular location.
        """

        stop_by = time.time() + timeout
        while True:
            try:
                if condition:
                    break
            except Exception, ex:
                pass

            # Enforce the specified timeout
            if time.time() > stop_by:
                break
            else:
                time.sleep(0.2)

    def close(self):
        if self.config['selenium']['close_browser_on_completion']:
            self.stop()

    def is_text_present_within(self, element_id, text):
        """
        Within the specified element, is the given text found
        """
        return (self.get_text(element_id).find(text) >= 0)

    def screenshot(self, msg='No description provided'):
        try:
            #convert msg to utf-8 encoded string
            msg = utils.encode_str(msg)
            args = {'background':'white'}
            base64 = self.capture_entire_page_screenshot_to_string(args)
            ss = {'base64':base64, 'msg':msg}
            self.test['_screenshots'].append(ss)
        except Exception, ex:
            self._logger.exception('Unable to capture screenshot:')

    def wait(self):
        self.wait_for_page_to_load(self.config.max_wait)

    def wait_for_seconds(self, seconds_to_wait):
        time.sleep(seconds_to_wait)

    def wait_for_text(self, text, timeout=60000):
        """
        Wait for text to appear on the page being loaded or until timeout
        occurs.
        """
        errors = []
        errors.append('errors')
        errors.append('If problems persist try again')
        errors.append('Purchase Trip Failure')
        errors.append('Supplier Processing Error')
        errors.append('We cannot process your request')
        locator = 'css=div.messageBoxContent'
        msg = 'Text not found: "%s". %dms timeout exceeded.' % (text, timeout)

        # Convert timeout from miliseconds to seconds
        timeout = timeout / 1000
        stop_by = time.time() + timeout

        if not text:
            self.test.assert_true(False, msg)
            return

        while True:
            try:
                text_is_present = self.is_text_present(text)
            except Exception, ex:
                text_is_present = False

            if text_is_present:
                # Provide a little padding to give the dom time to
                # finish rendering
                time.sleep(3)

                # Capture screenshot of new page if enabled
                if os.environ.get("VOLTAGE_TAKE_SCREENSHOTS", None):
                    _url = self.get_location()
                    self.screenshot("Auto captured screenshot of " + _url)

                break
            else:
                # Enforce the specified timeout
                if time.time() > stop_by:
                    # If there is a timeout, take a screenshot.
                    self.screenshot(msg)

                    # Check for the error text locator and log
                    # the corresponding text if present
                    try:
                        err_msg = self.get_text(locator)
                    except:
                        err_msg = None

                    if err_msg:
                        self.test.output(err_msg)

                    # Probe for and log additional error context
                    for error in errors:
                        try:
                            text_is_present = self.is_text_present(error)
                        except:
                            continue

                        if text_is_present:
                            err_msg = 'Found error string: %s' % error
                            self.test.output(err_msg)
                    break

                time.sleep(0.2)

        self.test.assert_true(self.is_text_present(text), msg)

    def wait_for_layer_disappear(self, layer_id, wait):
        """
        specifying a "layer" or an HTML element identifiable by id,
        allows this code to wait for the max amount of time for the
        layer to disappear.

        In this case, the disappearance is related to the element's
        visibility set to 'hidden'.
        """
        script = "selenium.browserbot.getCurrentWindow().document.getElementById('%s').style.visibility == 'hidden' || selenium.browserbot.getCurrentWindow().document.getElementById('%s').style.display == 'none'" % (layer_id, layer_id)

        if (self.is_element_present(layer_id)):
            self.wait_for_condition(script, wait)

    def is_regex_present_within(self, element_id, regex):
        """
        Within the specified element, is text matching the given regex found
        """

        element_text = self.get_text(element_id)
        # print "Element text: %s" % (element_text)
        return (re.search(regex, element_text) is not None)

    def waitForSpinnerLoad(self,msg=None):
        ct = 0
        if msg is None:
            msg = 'Working on your request. One moment, please...'

        while ct < 120:
            # if (browser.is_element_present('id=globalPartnersResultSpinnerWidget.animation') == False  and browser.is_visible('id=globalPartnersResultSpinnerWidget.animation') == False):
            try:
                text_is_present = self.is_text_present(msg)
            except Exception, ex:
                text_is_present = True
            if text_is_present == False:
                break
            time.sleep(2)
            ct = ct + 2
            #print self.is_text_present('Working on your request. One moment, please...')

    def browse_file(self,fieldLocator, fileLocator):
        fileLocator = os.path.join(self.config['VOLTAGE_ROOT'], fileLocator.replace("/", os.sep))

        if self.host == "localhost":
            self.type(fieldLocator, fileLocator)
        else:
            jobId = os.getenv("localhost","localhost") + str(os.getpid())
            filename = (fileLocator.rsplit(os.sep,1)[1]).split('.')[0]
            fileExtension = fileLocator.rsplit('.',1)[1]
            maskedFilePath = fileLocator.rsplit(os.sep,1)[0].replace(os.sep,'-')
            maskedFilename = filename + "-" + jobId + "-" + maskedFilePath + "." + fileExtension
            http_raw_client.HttpRawClient().put(FILESERVER,
                                                open(fileLocator).read(),
                                                headers={'filename': maskedFilename})
            self.attach_file(fieldLocator, FILESERVER + maskedFilename)

    def register_url(self):
        try:
            if not self.pages_explored:
                self.pages_explored = []
            location = self.get_location()
            page = self.get_page(location)
            if not page in self.pages_explored:
                self.pages_explored.append(page)
        except Exception:
            pass
        #print "The URL was registered, but the traffic is \n%s\n%s\n%s" % (self.captureNetworkTraffic("json"), self.captureNetworkTraffic("xml"), self.captureNetworkTraffic("plain"))

    def click(self,locator):
        self.register_url()
        super(Browser, self).click(locator)

#    def double_click(self,locator):
#    def context_menu(self,locator):
#    def click_at(self,locator,coordString):
#    def double_click_at(self,locator,coordString):
#    def context_menu_at(self,locator,coordString):
    def fire_event(self,locator,eventName):
        self.register_url()
        super(Browser, self).fire_event(locator,eventName)

#    def select(self,selectLocator,optionLocator):

    def submit(self,formLocator):
        self.register_url()
        super(Browser, self).submit(formLocator)

    def open(self,url):
        self.register_url()
        super(Browser, self).open(url)

    def open_window(self,url,windowID):
        self.register_url()
        super(Browser, self).open_window(url,windowID)

    def select_window(self, windowID, timeout=None, text=None):
        self.register_url()
        if timeout is None:
            timeout = self.config.max_wait
        stop_time = time.time() + timeout/1000
        while True:
            try:
                super(Browser, self).select_window(windowID)
                if text:
                    self.wait_for_text(text)
                break
            except Exception:
                if time.time() > stop_time:
                    raise NativeBrowserPopupException("Native Browser Popup did not appear !")
                else:
                    time.sleep(0.25)

#    def select_window(self,windowID):
#    def select_pop_up(self,windowID):
#    def select_frame(self,locator):
#    def drag_and_drop(self,locator,movementsString):
#    def drag_and_drop_to_object(self,locatorOfObjectToBeDragged,locatorOfDragDestinationObject):
    def wait_for_page_to_load(self,timeout):
        super(Browser, self).wait_for_page_to_load(timeout)

        # Capture screenshot of new page if enabled
        if os.environ.get("VOLTAGE_TAKE_SCREENSHOTS", None):
            _url = self.get_location()
            self.screenshot("Auto captured screenshot of " + _url)

        self.register_url()

    def wait_for_frame_to_load(self,frameAddress,timeout):
        super(Browser, self).wait_for_frame_to_load(frameAddress,timeout)
        self.register_url()

    def run_script(self,script):
        super(Browser, self).run_script(self,script)
        self.register_url()


    def has_stylesheet_class(self, element_id, stylesheet_class):
        resultString = self.get_eval("selenium.browserbot.getCurrentWindow().document.getElementById('%s').className" % (element_id))
        resultArray = resultString.split(" ")
        return resultArray.count(stylesheet_class) > 0

class NativeBrowserPopupException(Exception):
    pass

class WebDriverBrowser(webdriver.Remote, mixins.FlowMixin):
    def __init__(self, test, config=None):
        self.test = test
        self._logger = utils.get_logger()

        self.pages_explored = set([]);

        if config is None:
            self.config = voltage.config_loader.get_config()
        else:
            self.config = config

        if self.config.browser == 'android':
            desired_capabilities=webdriver.DesiredCapabilities.ANDROID
        elif self.config.browser == 'iphone':
            desired_capabilities=webdriver.DesiredCapabilities.IPHONE
        else:
            desired_capabilities=webdriver.DesiredCapabilities.FIREFOX

        while True:
            try:
                remote = self.config.fetch_remote()
                self.host, self.port = remote.split(':')
            except Exception, ex:
                print "In the exception"
            try:
                webdriver.Remote.__init__(
                    self,
                    command_executor='http://%s/wd/hub' % remote,
                    desired_capabilities=desired_capabilities,
                )

                self._logger.info('...Using browser via %s' % remote)
                break
            except Exception, ex:
                self._logger.error('Unable to hit:%s\n%s' % (remote, ex))
                self.config.dead_remote(remote)
                pass

    def close(self):
        if self.config['selenium']['close_browser_on_completion']:
            super(WebDriverBrowser, self).close()

    def execute_flow(self, *args, **kwargs):
        super(WebDriverBrowser, self).execute_flow(self, *args, **kwargs)

    def screenshot(self, msg='No description provided'):
        try:
            #convert msg to utf-8 encoded string
            msg = utils.encode_str(msg)
            base64 = self.get_screenshot_as_base64()
            ss = {'base64': base64, 'msg': msg}
            self.test['_screenshots'].append(ss)
        except Exception, ex:
            self._logger.exception('Unable to capture screenshot:')

class WebDriverChromeBrowser(webdriver.Chrome, WebDriverBrowser):
    """
    Browser class using the Chrome WebDriver bindings and chromedriver server.
    """
    def __init__(self, test, config=None):
        print "Hai everyone this is neat"
        self.test = test
        self._logger = utils.get_logger()

        self.pages_explored = set([]);

        if config is None:
            self.config = voltage.config_loader.get_config()
        else:
            self.config = config

        driver_path = os.path.join(self.config['VOLTAGE_ROOT'], 'lib/chromedriver')
        webdriver.Chrome.__init__(self, executable_path=driver_path)

    def execute(self, *args, **kwargs):
            print args, kwargs
            return webdriver.Chrome.execute(self, *args, **kwargs)


    def close(self):
        if not self.config['selenium']['close_browser_on_completion']:
            return
        if len(self.window_handles) == 1:
            self.quit()
        else:
            super(WebDriverChromeBrowser, self).close()

