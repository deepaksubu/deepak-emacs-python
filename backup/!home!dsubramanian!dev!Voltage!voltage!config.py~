import getpass
import glob
import os
import random
import re
import socket
import sys
import thread
import time
from datetime import datetime

if sys.version_info < (2, 6):
    import simplejson as json
else:
    import json

# Voltage imports
from voltage import input_helper
from voltage import protocol
from voltage import singleton_url_fetcher
from voltage import user_exceptions
from voltage import utils

# Caches for code namespace lookups
path_join = os.path.join

#List of browsers supported and to be updated if we add support for other browsers
BROWSER_LIST = {
    'chrome': '*googlechrome',
    'ie': '*iexploreproxy',
    'android': 'android',
    'iphone': 'iphone'}
HOSTNAME = socket.gethostname()
RE_MASTER_TOKEN = re.compile(r'(%.*?%)')
USER = getpass.getuser()

def deep_update(old, new, remove_nones=False):
    """
    Recursively update one dictionary from another.

    :type old:           dict
    :param old:          Original dictionary that will be updated
    :type new:           dict
    :param new:          The dictionary to be used to update/override old
    :type remove_nones:  bool
    :param remove_nones: Optional flag to remove any keys from new that
                         equal None. Defaults to False.
    """

    for key, value in new.iteritems():
        if remove_nones and value is None:
            continue
        if key in old:
            if isinstance(value, dict) and isinstance(old[key], dict):
                deep_update(old[key], value, remove_nones)
            else:
                old[key] = value
        else:
            old[key] = value

class SeleniumServerUnavailableError(Exception):
    pass

class Config(dict):
    """
    Singleton object containing various configuration information read in
    from the command line (or dictionary object passed in) and from reading
    in various config files.  Also handles processing of the command line.
    """
    def __new__(cls, options_dict=None, input_parser=None):
        """
        :type options_dict: :class:`dict`
        :param options_dict: Optional dictionary passed in instead of using
                             the command line.  The keys correspond to what
                             Optparse uses for storing the CLI values.
        :type input_parser: :class:`voltage.input_helper.InputParser`
        :param input_parser: Optional Instance of InputParser or its subclass
                             to be used for parsing command line arguments

        >>> options_dict = {'uidsuffix': 'CL123456',          # -a
        ...                 'browser_type': 'chrome',         # -b
        ...                 'collect_only': True,             # -c
        ...                 'test_dir': 'dir/path',           # -d
        ...                 'env': 'qa22',                    # -e
        ...                 'force': True,                    # -f
        ...                 'output_json': 'Results.json',    # -j
        ...                 'test_filelist': 'filelist/path', # -l
        ...                 'manual': True,                   # -m
        ...                 'no_publish': True,               # -n
        ...                 'remote': True,                   # -r
        ...                 'speed': '300',                   # -s
        ...                 'test_case': 'test/path',         # -t
        ...                 'uid': 'CL123456',                # -u
        ...                 'verbose': True,                  # -v
        ...                 'customseed': 'amex',             # -C
        ...                 'function_regex': 'exam[p]le.*',  # -F
        ...                 'label': 'customlabel',           # -L
        ...                 'browser_close': False,           # -O
        ...                 'priority': 'p1',                 # -P
        ...                 'repeat_count': 5,                # -R
        ...                 'seleniumrc': 'localhost:4444',   # -S
        ...                 'threads': 4,                     # -T
        ...                 'no_writeover': True,             # -W
        ...                 'testslist': ['rpaLogin.py']}

        For further information regarding the command line options,
        please execute ``bin/run -h`` or see :ref:`basic-usage-label`.
        """

        # Implement the singleton pattern only creating the instance
        # at most once.
        if not '_the_instance' in cls.__dict__:
            cls._the_instance = dict.__new__(cls)
            cls._initialize(cls._the_instance, options_dict=options_dict,
                             input_parser=input_parser)

        return cls._the_instance

    def __setattr__(self, key, value):
        self._setvalue(key, value)

    def __setitem__(self, key, value):
        self._setvalue(key, value)

    def _setvalue(self, key, value):
        """
        Since we want setting a value with either dict access
        or attribute access to be in sync, both __setattr__ and
        __setitem__ will call this function
        """
        self.__dict__[key] = value
        dict.__setitem__(self, key, value)

    def _initialize(self, options_dict=None, input_parser=None):
        # Expose the top level filesystem paths as exposed _ONLY_ by
        # testrunner/runner.py.

        if input_parser is None:
            input_parser = input_helper.InputParser()

        if options_dict is None:
            options_dict = {}

        #set the browser_list in the config object
        self['browser_list'] = BROWSER_LIST
        self['VOLTAGE_ROOT'] = options_dict.get('VOLTAGE_ROOT', "")
        self['SHELL_ROOT'] = options_dict.get('SHELL_ROOT', "")

        # Create a lock for thread safety
        self.__dict__['lock'] = thread.allocate_lock()

        # Read in Command Line
        # Since the loggers can't be setup until after reading in all
        # the input options but, reading in the input options may need
        # loggers to be setup if ConfigError exception is raised,
        # catch and store it here and raise it after the loggers
        # are set up
        config_ex = None
        try:
            self._fetch_input_options(options_dict, input_parser)
        except user_exceptions.ConfigError, ex:
            config_ex = ex

        #Get Options for Logger
        verbose_flag = options_dict.get('verbose', False)

        if 'stdout' in options_dict:
            stdout = options_dict['stdout']
            #Delete from dictionary since file object is not json
            #serializable
            del options_dict['stdout']
        else:
            stdout = sys.stdout

        if 'stderr' in options_dict:
            stderr = options_dict['stderr']
            #Delete from dictionary since file object is not json
            #serializable
            del options_dict['stderr']
        else:
            stderr = sys.stderr

        self.__dict__['_logger'] = utils.create_logger(verbose_flag, stdout,
                                                       stderr)

        if config_ex:
            utils.clean_exit(options_dict, config_ex)

        # Currently Unique id is an parameter for ./bin/run
        # (We might generate it @ runtime in future)
        self['uid'] = options_dict.get('uid','')
        self['uidsuffix'] = options_dict.get('uidsuffix','')

        # Update with the env specific settings
        # No need to pass in a default since env will
        # already be set by this point.
        self.env = options_dict.get('env')

        # Read in various json config files
        self._read_all_configs(options_dict)

        # Override anything else that may be set with the
        # values passed in through main param list, cli, or debug.json
        deep_update(self, options_dict)

        # Based on the input params, generate the test list
        self._generate_test_list()

        # Variable substitution within Hash map
        # self.deep_variableSubstitution(self)

        # Finish up the config setup, which includes processing the
        # passed in values, casting some configs as attribute for
        # easier use, and setting a few other values
        self._set_attributes()

        # Define uniqe data per test run
        self.set_unique_trip_id()

    def set_unique_trip_id(self):
        self.test_id = random.randrange(10000000, 99999999)

    def _fetch_input_options(self, options_dict, input_parser):
        """
        Fetch Input arguments from command line or from _debug.json depending
        upon whether the code is ran from command line or eclipse respectively.
        """
        if 'env' in options_dict:
            # If options_dict already has an env key than it means that dict
            # has been already populated and hence you are done
            return

        elif len(sys.argv) <= 1:
            # If you are running from eclipse there are no command line args
            # and hence you must read options from _debug.json
            try:
                debug_dict = input_parser.parse_debug_config(self.VOLTAGE_ROOT)
            except ValueError:
                msg = '"config/_debug.json" contains invalid JSON.  '
                msg += 'Please update it and try again'
                raise user_exceptions.ConfigError(msg)

            #If env is not set than thrown an exception
            if debug_dict.get('env') is None:
                msg = 'Please update "config/_debug.json" with proper values'
                raise user_exceptions.ConfigError(msg)

            options_dict.update(debug_dict)

        else:
            #Read options from command line
            cl_options, args = input_parser.parse_command_line_args()
            # optparser sets any options that aren't passed in to None.
            # But its easier to just not have them in the new dictionary.
            deep_update(options_dict, vars(cl_options), remove_nones=True)

    def fetch_remote(self):
        servers = self['selenium']['servers']
        print "Deepak here: servers", servers

        try:
            self.lock.acquire()
            return servers[random.randrange(len(servers))]

        except ValueError, ex:
            msg = '\n\nIs selenium-server running?  Try: ./bin/selenium-server'
            time.sleep(2)
            raise SeleniumServerUnavailableError(msg)

        finally:
            self.lock.release()

    def dead_remote(self, remote):
        self.lock.acquire()
        if remote in self['selenium']['servers']:
            self['selenium']['servers'].remove(remote)
        self.lock.release()

    def _fetch_remotes(self):
        SELENIUM_HOSTS = singleton_url_fetcher.SingletonURL().url + '/api/cloud/selenium_healthy'
        return protocol.HttpRawClient().get(SELENIUM_HOSTS).json.get('data', [])

    def master_repl(self, match):
        """
        Replacement function to replace tokens in a config file with
        values from master.json.  This method is intended for use with
        re.sub(), specifically when the replacement value passed to
        re.sub() is a function.

        :param m: Each match in a regular expression search
        :type m: _sre.SRE_Match
        :return: str

        REFERENCE: http://docs.python.org/library/re.html#re.sub
        """
        replace_token = match.group(0)
        if match.group(0) == "%env%":
            replace_token = self.full_env
        elif match.group(0) == "%uid%":
            replace_token = self.get('uid')
        elif match.group(0) == "%uidsuffix%":
            replace_token = self.get('uidsuffix')
        elif match.group(0).strip('%') in self.env_master['global'].keys():
                replace_token = self.env_master['global'][match.group(0).strip('%')]

        if self.env in self.env_master:
            if match.group(0).strip('%') in self.env_master[self.env].keys():
                replace_token = self.env_master[self.env][match.group(0).strip('%')]
        elif "dev" in self.env_master:
            if match.group(0).strip('%') in self.env_master['dev'].keys():
                replace_token = self.env_master['dev'][match.group(0).strip('%')]

        return replace_token

    def getreplaceValue(self, m):
        # TODO: Clean this up
        self2 = self
        for eachItem in (m.group(0).strip('%')).split('.'):
            try:
                if self2[eachItem] <> "":
                    self2 = self2[eachItem]
            except KeyError:
                    return m.group(0)
        return self2

    def deep_variableSubstitution(self, self1):
        # TODO: Clean this up
        for key, value in self1.iteritems():
            if isinstance(value, dict) and isinstance(self1[key], dict):
                self.deep_variableSubstitution(self1[key])
            else:
                if isinstance(value, int):
                    value = unicode(value)
                try:
                    if type(value).__name__ <> 'list':
                        val = re.sub('%.*?%', self.getreplaceValue, value)
                        self[key] = val
                except Exception, ex:
                     self._logger.exception("%s\n" % ex)

    def _read_all_configs(self, options_dict):
        """
        Aggregates reading in of all the various different config files
        """

        # Load Environemnt specific properties like backdoor hosts,
        # ports etc followed by the default configuration.
        self.full_env = self.env

        self.env_master = {}
        self.env_master =  self.read_config(path_join('global', 'master.json'), options_dict)

        if self.env not in self.env_master:
            self.full_env = ".%s.mygazoo" %self.env

        deep_update(self, self.read_config(path_join('global','defaults.json'), options_dict))

        # Assume a QA env first, then prod env, then look for a dev environment
        env_types = ['qaenvs', 'prodenvs', 'devenvs']
        for env_type in env_types:
            try:
                deep_update(self, self.read_config(path_join(env_type, '%s.json' % self.env), options_dict))
                break
            except IOError, ex:
                if env_type == env_types[-1]:
                    self._logger.error("ERROR: No config file found for %s.json\n" % self.env)
                    utils.clean_exit(options_dict, ex)

        # Loading of seed config was previously done here.  It is now loaded
        # after the test cases are collected.

        # Override any properties defined in overrides.properties.  If
        # the file does not exist, move on (nothing to override).
        try:
            deep_update(self, self.read_config('_overrides.json', options_dict))
        except IOError:
            pass

    def read_config(self, relative_path, options_dict=None):
        """
        Read the passed configuration file, returning a dictionary.
        All files fetched are relative to the config directory.
        """

        full_path = path_join(self['VOLTAGE_ROOT'], 'config', relative_path)
        config_txt = open(full_path).read()
        tokenized_txt = RE_MASTER_TOKEN.sub(self.master_repl, config_txt)

        try:
            return json.loads(tokenized_txt)
        except ValueError, ex:
            self._logger.error('ERROR: Invalid json: %s' % full_path)
            utils.clean_exit(options_dict, ex)

    #Read_config file reads file from only config directoty. But, read_config_any method reads from any where
    def read_config_any(self, relative_path, options_dict=None):
        """  Reads file from any directory """
        full_path = path_join(self['VOLTAGE_ROOT'], relative_path)
        config_txt = open(full_path).read()
        tokenized_txt = RE_MASTER_TOKEN.sub(self.master_repl, config_txt)

        try:
            return json.loads(tokenized_txt)
        except ValueError, ex:
            self._logger.error('ERROR: Invalid json: %s' % full_path)
            utils.clean_exit(options_dict, ex)

    def read_all_customseed(self, options_dict=None):
        """
        Read the custom seed configs based on the requirements of the tests
        as specified in the docstrings and based on the 'customseed' arg in
        options_dict.

        :type options_dict: :class:`dict`
        :param options_dict: Optional dictionary containing options either
                             passed in as a dictionary or entered from the
                             command line.
        """
        # We include any command-line seed for backwards compatibility.
        opt_seed = options_dict.get('customseed', None)
        # self['customseed'] is set in testrunner.tests.Tests
        if not self.has_key('customseed'):
            self['customseed'] = []
        if opt_seed and opt_seed not in self['customseed']:
            self['customseed'].append(opt_seed)

        for seed in self['customseed']:
            # TODO: This needs to be removed, and replaced with a
            # webservice call (honoring zero touch).
            custom_json_path = path_join('seed', seed.split('.')[0] + '.json')
            deep_update(self, self.read_config(custom_json_path, options_dict))

        # Override any properties defined in overrides.properties.  If
        # the file does not exist, move on (nothing to override).
        try:
            deep_update(self, self.read_config('_overrides.json', options_dict))
        except IOError:
            pass

    def _generate_test_list(self):
        """
        We need to generate and validate the list of tests based on
        the parameters that were passed in.
        """

        # Walk through the directory if it exists
        if 'test_dir' in self:
            self['test_dir'] = utils.get_platform_dependent_path(self['test_dir'])
            self['test_dir'] = path_join(self['SHELL_ROOT'], self['test_dir'])
            if os.path.isdir(self['test_dir']):
                testlist = []
                for (dirpath, dirnames, filenames) in os.walk(self['test_dir']):
                    testlist.extend(glob.glob(path_join(dirpath, '*.py')))

                err_str = 'ERROR: No valid test cases found in dir:' \
                          + self['test_dir']
                self._check_for_tests(testlist, err_str)

                self['test_list'] = testlist

            else:
                err_msg = 'ERROR: Cannot find directory: ' + self['test_dir']
                utils.clean_exit(self, user_exceptions.ConfigError(err_msg))

        # Read in the filelist and parse it (if it exists)
        elif 'test_filelist' in self:
            self['test_filelist'] = utils.get_platform_dependent_path(self['test_filelist'])
            self['test_filelist'] = path_join(self['SHELL_ROOT'], self['test_filelist'])
            if os.path.isfile(self['test_filelist']):
                f = open(self['test_filelist'], "r")
                testlist = []

                # Remove any lines that are comments and make
                # sure the files exist
                for testcase in f:
                    if testcase[0] == '#':
                        continue
                    testcase = path_join(self['VOLTAGE_ROOT'],testcase)
                    testcase = utils.get_platform_dependent_path(testcase)
                    if os.path.isfile(testcase.strip()):
                        testlist.append(testcase.strip())
                f.close()

                err_str = 'ERROR: No valid test cases found in filelist:' \
                          + self['test_filelist']
                self._check_for_tests(testlist, err_str)

                self['test_list'] = testlist

            else:
                err_msg = 'ERROR: Cannot find filelist: ' + self['test_filelist']
                utils.clean_exit(self, user_exceptions.ConfigError(err_msg))

        # Ordinary single test
        elif 'test_case' in self:
            self['test_case'] = utils.get_platform_dependent_path(self['test_case'])
            self['test_case'] = path_join(self['SHELL_ROOT'], self['test_case'])
            if os.path.isfile(self['test_case']):
                self['test_list'] = [self['test_case']]
            else:
                err_msg = 'ERROR: Cannot find testcase: ' + self['test_case']
                utils.clean_exit(self, user_exceptions.ConfigError(err_msg))

        # List of test cases
        elif 'testslist' in self:
            testlist = []
            for testcase in self['testslist']:
                testcase = path_join(self['SHELL_ROOT'], testcase)
                testcase = utils.get_platform_dependent_path(testcase)
                if os.path.isfile(testcase.strip()):
                    testlist.append(testcase.strip())

            err_str = 'ERROR: No valid test cases found in the provided testslist'

            self._check_for_tests(testlist, err_str)
            self['test_list'] = testlist

        #No test cases selected
        else:
            err_msg = 'ERROR: No test cases have been selected'
            utils.clean_exit(self, user_exceptions.ConfigError(err_msg))

        # Filter tests based on the priority passed in
        if 'priority' in self:
            priority_regex = "priority[: ]+P" + self['priority']
            err_str = 'ERROR: No test cases match priority' + self['priority']
            self['test_list'] = self._filter_tests(priority_regex, err_str)

        # Manual test filtering
        manual_regex = "type[: ]+manual"
        if self.get('manual', False):
            # Filter tests to find only manual tests
            err_str = 'ERROR: No test cases match manual filtering'
            self['test_list'] = self._filter_tests(manual_regex, err_str)
        else:
            # Remove any manual tests based on if the don't
            # match the regex
            manual_re = re.compile(manual_regex, re.I)
            testlist = []
            for test in self['test_list']:
                f = open(test, "r")
                if manual_re.search(f.read()):
                    self._logger.info("!!! Skipping test flagged as manual %s" % test)
                else:
                    testlist.append(test)
                f.close()

            err_str = 'ERROR: No non-manual tests found'
            self._check_for_tests(testlist, err_str)

            self['test_list'] = testlist


    def _filter_tests(self, regex, err_str):
        """
        Filter tests based on if the file has the matching regex

        :type  regex:   str
        :param regex:   A string representing the regex pattern
        :type  err_str: str
        :param err_str: The error message to display if no tests are matched
        :rtype:         list
        :return:        The list of matching tests
        """
        compiled_re = re.compile(regex, re.I)
        testlist = []
        for test in self['test_list']:
            f = open(test, "r")
            if compiled_re.search(f.read()):
                testlist.append(test)
            f.close()

        self._check_for_tests(testlist, err_str)

        return testlist

    def _check_for_tests(self, testlist, err_str):
        """
        Make sure we found some tests.  Exit if we didn't.

        :type  testlist: list
        :param testlist: The list of tests to check
        :type  err_str:  str
        :param err_str:  The error message to display if testlist is empty
        """
        if not testlist:
            utils.clean_exit(self, user_exceptions.ConfigError(err_str))


    def _set_attributes(self):
        """
        Set all the attributes we need that have not been
        set elsewhere.
        """

        # Determine which cluster is under test
        default = self['rpa']['default_cluster']
        cluster = self.get('cluster', default)
        rpa = self['rpa'][cluster]

        # Selenium settings
        self.browser = self['selenium']['browser']
        self.max_wait = self['selenium']['max_wait']
        self.screenshots = self['selenium']['screenshot_dir']
        self.speed = self.get('speed', self['selenium']['speed'])

        # RPA settings
        self.password = rpa['password']
        self.target = rpa['url']
        self.username = rpa['username']

        # Console settings
        self.console = self['console']

        # Host detail
        self.hosts_cluster = self['hosts'][cluster]
        self.hosts_mgmt = self['hosts']['mgmt']

        # Cast a few types
        self.max_wait = int(self.max_wait)
        self.speed = int(self.speed)

        # Set other variables from checking system
        self['hostname'] = HOSTNAME
        self['origin'] = HOSTNAME
        self['localhost'] = HOSTNAME
        self['user'] = USER

        # Check if browser type was passed in the CLI or else use the default contained in defaults.json
        self.browser = self['browser_list'].get(self.get('browser_type'), self['selenium']['browser'])

        # Override the config with cli args (exposed as env vars)
        if self.get('force', False):
            self['use_health_check'] = False

        # Support reading the files regardless of environment state
        if self.get('collect_only', False):
            self['use_health_check'] = False

        # Was a specific selenium-server specified
        if self.get('seleniumrc'):
            self['selenium']['servers'] = [self.get('seleniumrc')]

        # Support leaving the browser open for debugging
        if not self.get('browser_close', True):
            self['selenium']['close_browser_on_completion'] = False

        # Should the tests be executed remotely
        if self.get('remote', False):
            self['selenium']['servers'] = self._fetch_remotes()
            if self.get('browser_type') == 'ie':
                err_msg = 'Remote execution using IE not supported'
                utils.clean_exit(self, user_exceptions.ConfigError(err_msg))


            # With remote (headless) execution we MUST close the browser!
            self['selenium']['close_browser_on_completion'] = True

        # Dont publish if the no_publish option was specified
        if self.get('no_publish', False):
            self['publish'] = False

        # Set no_writeover if we have tests of the same name
        if self.get('repeat_count', 1) > 1:
            self['no_writeover'] = True

        # Get publish status from the singleton
        if not singleton_url_fetcher.SingletonURL().publish:
            self['publish'] = False

        # Generate the label if it wasn't passed in.
        if 'label' not in self:
            curr_time = datetime.now().strftime("%y-%m-%d-%H-%M-%S")
            # Assemble a list with the label info
            label_list = [curr_time]
            label_list.append('-')
            label_list.append(self.get('user'))
            label_list.append('_')
            label_list.append(str(os.getpid()))
            label_list.append('-')
            label_list.append(self.get('env'))
            # Remove any special characters and new lines
            self['label'] = re.sub(r'[^-a-zA-Z0-9_]+', "",
                                   ''.join(label_list)).strip()


if __name__ == '__main__':
    import pprint
    cfg = Config()
    pprint.pprint(cfg)
